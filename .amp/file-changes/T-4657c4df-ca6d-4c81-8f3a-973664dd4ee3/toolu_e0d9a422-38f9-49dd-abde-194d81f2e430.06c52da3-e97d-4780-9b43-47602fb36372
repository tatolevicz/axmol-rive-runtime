{
  "id": "06c52da3-e97d-4780-9b43-47602fb36372",
  "uri": "file:///Users/arthurmotelevicz/Projects/AITomatoes/axmol_rive/HelloWorld/Source/AxmolRive.cpp",
  "before": "",
  "after": "#include \"AxmolRive.h\"\n\n// Helper to convert Rive ColorInt to Axmol Color4B\nstatic ax::Color4B toAxColor(rive::ColorInt color) {\n    unsigned int r = rive::colorRed(color);\n    unsigned int g = rive::colorGreen(color);\n    unsigned int b = rive::colorBlue(color);\n    unsigned int a = rive::colorAlpha(color);\n    return ax::Color4B(r, g, b, a);\n}\n\n// AxmolRenderPath Implementation\nAxmolRenderPath::AxmolRenderPath(rive::RawPath& rawPath, rive::FillRule fillRule)\n    : rive::TessRenderPath(rawPath, fillRule) {\n}\n\nvoid AxmolRenderPath::addTriangles(rive::Span<const rive::Vec2D> vertices, rive::Span<const uint16_t> indices) {\n    // Copy vertices and indices to storage\n    size_t baseIndex = _rawVertices.size();\n    \n    for (const auto& v : vertices) {\n        _rawVertices.push_back(v);\n    }\n    \n    for (const auto& idx : indices) {\n        _rawIndices.push_back(static_cast<unsigned short>(baseIndex + idx));\n    }\n}\n\nvoid AxmolRenderPath::setTriangulatedBounds(const rive::AABB& value) {\n    // Optional: Use this to optimize culling\n}\n\n// AxmolRenderPaint Implementation\nAxmolRenderPaint::AxmolRenderPaint() {}\nvoid AxmolRenderPaint::style(rive::RenderPaintStyle style) { _style = style; }\nvoid AxmolRenderPaint::color(rive::ColorInt value) { _color = value; }\nvoid AxmolRenderPaint::thickness(float value) { _thickness = value; }\nvoid AxmolRenderPaint::join(rive::StrokeJoin value) { _join = value; }\nvoid AxmolRenderPaint::cap(rive::StrokeCap value) { _cap = value; }\nvoid AxmolRenderPaint::blendMode(rive::BlendMode value) { _blendMode = value; }\nvoid AxmolRenderPaint::shader(rive::rcp<rive::RenderShader> shader) { /* Store shader if needed */ }\nvoid AxmolRenderPaint::invalidateStroke() { /* Handle invalidation if caching */ }\n\n// AxmolRenderer Implementation\nAxmolRenderer::AxmolRenderer(ax::DrawNode* drawNode) : _drawNode(drawNode) {}\n\nvoid AxmolRenderer::clipPath(rive::RenderPath* path) {\n    // Axmol DrawNode doesn't support arbitrary clipping easily.\n    // We can use Stencil Buffer in Axmol, but Renderer::clipPath implies a stack.\n    // TessRenderer handles the stack logic and provides m_Stack.\n    // But actually applying the clip to the DrawNode is hard.\n    // For now, we IGNORE clipping or use scissor test if it's a rect.\n    // Rive clipping can be complex paths.\n    // To support this properly, we'd need to use ax::ClippingNode or custom stencil commands.\n    // Given we are using a single DrawNode, clipping is difficult.\n    // MVP: Ignore clipping.\n}\n\nvoid AxmolRenderer::drawPath(rive::RenderPath* path, rive::RenderPaint* paint) {\n    auto axPath = static_cast<AxmolRenderPath*>(path);\n    auto axPaint = static_cast<AxmolRenderPaint*>(paint);\n    \n    // Clear temp storage in path\n    axPath->_rawVertices.clear();\n    axPath->_rawIndices.clear();\n    \n    if (axPaint->_style == rive::RenderPaintStyle::stroke) {\n        // Generate stroke geometry\n        // Note: contour might need to be called if not already done for this transform?\n        // TessRenderPath::extrudeStroke calls contour() internally? \n        // No, checking source, we usually call contour() first.\n        axPath->contour(transform());\n        axPath->extrudeStroke(nullptr, axPaint->_join, axPaint->_cap, axPaint->_thickness, transform());\n    } else {\n        // Generate fill geometry\n        axPath->contour(transform());\n        axPath->triangulate(axPath);\n    }\n    \n    // Now draw the triangles\n    if (axPath->_rawVertices.empty() || axPath->_rawIndices.empty()) {\n        return;\n    }\n\n    ax::Color4B c = toAxColor(axPaint->_color);\n    \n    // Apply opacity from blend mode or assume it's mixed?\n    // Rive handles opacity in color usually.\n    \n    for (size_t i = 0; i < axPath->_rawIndices.size(); i += 3) {\n        if (i + 2 >= axPath->_rawIndices.size()) break;\n        \n        unsigned short i1 = axPath->_rawIndices[i];\n        unsigned short i2 = axPath->_rawIndices[i+1];\n        unsigned short i3 = axPath->_rawIndices[i+2];\n        \n        const auto& v1 = axPath->_rawVertices[i1];\n        const auto& v2 = axPath->_rawVertices[i2];\n        const auto& v3 = axPath->_rawVertices[i3];\n        \n        _drawNode->drawTriangle(\n            ax::Vec2(v1.x, v1.y),\n            ax::Vec2(v2.x, v2.y),\n            ax::Vec2(v3.x, v3.y),\n            c\n        );\n    }\n}\n\n// AxmolFactory Implementation\nrive::rcp<rive::RenderBuffer> AxmolFactory::makeRenderBuffer(rive::RenderBufferType, rive::RenderBufferFlags, size_t sizeInBytes) {\n    return nullptr;\n}\n\nrive::rcp<rive::RenderShader> AxmolFactory::makeLinearGradient(\n    float sx, float sy, float ex, float ey,\n    const rive::ColorInt colors[], const float stops[], size_t count) {\n    return nullptr; \n}\n\nrive::rcp<rive::RenderShader> AxmolFactory::makeRadialGradient(\n    float cx, float cy, float radius,\n    const rive::ColorInt colors[], const float stops[], size_t count) {\n    return nullptr;\n}\n\nrive::rcp<rive::RenderPath> AxmolFactory::makeRenderPath(rive::RawPath& rawPath, rive::FillRule fillRule) {\n    return rive::make_rcp<AxmolRenderPath>(rawPath, fillRule);\n}\n\nrive::rcp<rive::RenderPath> AxmolFactory::makeEmptyRenderPath() {\n    rive::RawPath emptyPath;\n    return rive::make_rcp<AxmolRenderPath>(emptyPath, rive::FillRule::nonZero);\n}\n\nrive::rcp<rive::RenderPaint> AxmolFactory::makeRenderPaint() {\n    return rive::make_rcp<AxmolRenderPaint>();\n}\n\nrive::rcp<rive::RenderImage> AxmolFactory::decodeImage(rive::Span<const uint8_t>) {\n    return nullptr;\n}\n",
  "diff": "Index: file:///Users/arthurmotelevicz/Projects/AITomatoes/axmol_rive/HelloWorld/Source/AxmolRive.cpp\n===================================================================\n--- file:///Users/arthurmotelevicz/Projects/AITomatoes/axmol_rive/HelloWorld/Source/AxmolRive.cpp\toriginal\n+++ file:///Users/arthurmotelevicz/Projects/AITomatoes/axmol_rive/HelloWorld/Source/AxmolRive.cpp\tmodified\n@@ -0,0 +1,143 @@\n+#include \"AxmolRive.h\"\n+\n+// Helper to convert Rive ColorInt to Axmol Color4B\n+static ax::Color4B toAxColor(rive::ColorInt color) {\n+    unsigned int r = rive::colorRed(color);\n+    unsigned int g = rive::colorGreen(color);\n+    unsigned int b = rive::colorBlue(color);\n+    unsigned int a = rive::colorAlpha(color);\n+    return ax::Color4B(r, g, b, a);\n+}\n+\n+// AxmolRenderPath Implementation\n+AxmolRenderPath::AxmolRenderPath(rive::RawPath& rawPath, rive::FillRule fillRule)\n+    : rive::TessRenderPath(rawPath, fillRule) {\n+}\n+\n+void AxmolRenderPath::addTriangles(rive::Span<const rive::Vec2D> vertices, rive::Span<const uint16_t> indices) {\n+    // Copy vertices and indices to storage\n+    size_t baseIndex = _rawVertices.size();\n+    \n+    for (const auto& v : vertices) {\n+        _rawVertices.push_back(v);\n+    }\n+    \n+    for (const auto& idx : indices) {\n+        _rawIndices.push_back(static_cast<unsigned short>(baseIndex + idx));\n+    }\n+}\n+\n+void AxmolRenderPath::setTriangulatedBounds(const rive::AABB& value) {\n+    // Optional: Use this to optimize culling\n+}\n+\n+// AxmolRenderPaint Implementation\n+AxmolRenderPaint::AxmolRenderPaint() {}\n+void AxmolRenderPaint::style(rive::RenderPaintStyle style) { _style = style; }\n+void AxmolRenderPaint::color(rive::ColorInt value) { _color = value; }\n+void AxmolRenderPaint::thickness(float value) { _thickness = value; }\n+void AxmolRenderPaint::join(rive::StrokeJoin value) { _join = value; }\n+void AxmolRenderPaint::cap(rive::StrokeCap value) { _cap = value; }\n+void AxmolRenderPaint::blendMode(rive::BlendMode value) { _blendMode = value; }\n+void AxmolRenderPaint::shader(rive::rcp<rive::RenderShader> shader) { /* Store shader if needed */ }\n+void AxmolRenderPaint::invalidateStroke() { /* Handle invalidation if caching */ }\n+\n+// AxmolRenderer Implementation\n+AxmolRenderer::AxmolRenderer(ax::DrawNode* drawNode) : _drawNode(drawNode) {}\n+\n+void AxmolRenderer::clipPath(rive::RenderPath* path) {\n+    // Axmol DrawNode doesn't support arbitrary clipping easily.\n+    // We can use Stencil Buffer in Axmol, but Renderer::clipPath implies a stack.\n+    // TessRenderer handles the stack logic and provides m_Stack.\n+    // But actually applying the clip to the DrawNode is hard.\n+    // For now, we IGNORE clipping or use scissor test if it's a rect.\n+    // Rive clipping can be complex paths.\n+    // To support this properly, we'd need to use ax::ClippingNode or custom stencil commands.\n+    // Given we are using a single DrawNode, clipping is difficult.\n+    // MVP: Ignore clipping.\n+}\n+\n+void AxmolRenderer::drawPath(rive::RenderPath* path, rive::RenderPaint* paint) {\n+    auto axPath = static_cast<AxmolRenderPath*>(path);\n+    auto axPaint = static_cast<AxmolRenderPaint*>(paint);\n+    \n+    // Clear temp storage in path\n+    axPath->_rawVertices.clear();\n+    axPath->_rawIndices.clear();\n+    \n+    if (axPaint->_style == rive::RenderPaintStyle::stroke) {\n+        // Generate stroke geometry\n+        // Note: contour might need to be called if not already done for this transform?\n+        // TessRenderPath::extrudeStroke calls contour() internally? \n+        // No, checking source, we usually call contour() first.\n+        axPath->contour(transform());\n+        axPath->extrudeStroke(nullptr, axPaint->_join, axPaint->_cap, axPaint->_thickness, transform());\n+    } else {\n+        // Generate fill geometry\n+        axPath->contour(transform());\n+        axPath->triangulate(axPath);\n+    }\n+    \n+    // Now draw the triangles\n+    if (axPath->_rawVertices.empty() || axPath->_rawIndices.empty()) {\n+        return;\n+    }\n+\n+    ax::Color4B c = toAxColor(axPaint->_color);\n+    \n+    // Apply opacity from blend mode or assume it's mixed?\n+    // Rive handles opacity in color usually.\n+    \n+    for (size_t i = 0; i < axPath->_rawIndices.size(); i += 3) {\n+        if (i + 2 >= axPath->_rawIndices.size()) break;\n+        \n+        unsigned short i1 = axPath->_rawIndices[i];\n+        unsigned short i2 = axPath->_rawIndices[i+1];\n+        unsigned short i3 = axPath->_rawIndices[i+2];\n+        \n+        const auto& v1 = axPath->_rawVertices[i1];\n+        const auto& v2 = axPath->_rawVertices[i2];\n+        const auto& v3 = axPath->_rawVertices[i3];\n+        \n+        _drawNode->drawTriangle(\n+            ax::Vec2(v1.x, v1.y),\n+            ax::Vec2(v2.x, v2.y),\n+            ax::Vec2(v3.x, v3.y),\n+            c\n+        );\n+    }\n+}\n+\n+// AxmolFactory Implementation\n+rive::rcp<rive::RenderBuffer> AxmolFactory::makeRenderBuffer(rive::RenderBufferType, rive::RenderBufferFlags, size_t sizeInBytes) {\n+    return nullptr;\n+}\n+\n+rive::rcp<rive::RenderShader> AxmolFactory::makeLinearGradient(\n+    float sx, float sy, float ex, float ey,\n+    const rive::ColorInt colors[], const float stops[], size_t count) {\n+    return nullptr; \n+}\n+\n+rive::rcp<rive::RenderShader> AxmolFactory::makeRadialGradient(\n+    float cx, float cy, float radius,\n+    const rive::ColorInt colors[], const float stops[], size_t count) {\n+    return nullptr;\n+}\n+\n+rive::rcp<rive::RenderPath> AxmolFactory::makeRenderPath(rive::RawPath& rawPath, rive::FillRule fillRule) {\n+    return rive::make_rcp<AxmolRenderPath>(rawPath, fillRule);\n+}\n+\n+rive::rcp<rive::RenderPath> AxmolFactory::makeEmptyRenderPath() {\n+    rive::RawPath emptyPath;\n+    return rive::make_rcp<AxmolRenderPath>(emptyPath, rive::FillRule::nonZero);\n+}\n+\n+rive::rcp<rive::RenderPaint> AxmolFactory::makeRenderPaint() {\n+    return rive::make_rcp<AxmolRenderPaint>();\n+}\n+\n+rive::rcp<rive::RenderImage> AxmolFactory::decodeImage(rive::Span<const uint8_t>) {\n+    return nullptr;\n+}\n",
  "isNewFile": true,
  "reverted": false,
  "timestamp": 1763773287566
}