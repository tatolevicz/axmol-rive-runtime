{
  "id": "c2ca2765-e5d1-4397-a8f3-f959d57d14f9",
  "uri": "file:///Users/arthurmotelevicz/Projects/AITomatoes/axmol_rive/HelloWorld/Source/MainScene.cpp",
  "before": "#include \"MainScene.h\"\n#include \"rive/math/mat2d.hpp\"\n\nusing namespace ax;\n\nMainScene::MainScene()\n{\n}\n\nMainScene::~MainScene()\n{\n    if (_touchListener)\n        _eventDispatcher->removeEventListener(_touchListener);\n}\n\nbool MainScene::init()\n{\n    if (!Scene::init())\n    {\n        return false;\n    }\n\n    auto visibleSize = _director->getVisibleSize();\n    auto origin = _director->getVisibleOrigin();\n    auto safeArea = _director->getSafeAreaRect();\n\n    // 1. Background\n    auto background = LayerColor::create(Color32(40, 40, 40, 255));\n    this->addChild(background, 0);\n\n    // 2. DrawNode for Rive\n    _riveDrawNode = DrawNode::create();\n    this->addChild(_riveDrawNode, 1);\n\n    // 3. Initialize Rive\n    _riveFactory = std::make_unique<AxmolFactory>();\n    _riveRenderer = std::make_unique<AxmolRenderer>(_riveDrawNode);\n\n    // 4. Load .riv File\n    auto fileUtils = FileUtils::getInstance();\n    std::string fullPath = fileUtils->fullPathForFilename(\"marty.riv\");\n    \n    if (fullPath.empty()) {\n        AXLOG(\"Error: marty.riv not found!\");\n    } else {\n        auto data = fileUtils->getDataFromFile(fullPath);\n        if (!data.isNull()) {\n            rive::Span<const uint8_t> bytes(data.getBytes(), data.getSize());\n            \n            rive::ImportResult result;\n            _riveFile = rive::File::import(bytes, _riveFactory.get(), &result);\n            \n            if (_riveFile) {\n                _artboard = _riveFile->artboardDefault();\n                if (_artboard) {\n                    _artboard->advance(0.0f);\n                    \n                    // Play the first animation if available\n                    // auto anim = _artboard->animationAt(0);\n                    // if (anim) {\n                    //    _riveScene = _artboard->instance(); // Wait, Scene/StateMachine logic\n                    // }\n                    // Simple animation playback using LinearAnimationInstance directly?\n                    // Or just advance artboard if it has a state machine?\n                    // For now just show the artboard.\n                    \n                    AXLOG(\"Rive file loaded successfully!\");\n                }\n            } else {\n                AXLOG(\"Failed to import Rive file.\");\n            }\n        }\n    }\n\n    // 5. Close Button\n    auto closeItem = MenuItemImage::create(\"CloseNormal.png\", \"CloseSelected.png\",\n                                           AX_CALLBACK_1(MainScene::menuCloseCallback, this));\n    if (closeItem) {\n        float x = safeArea.origin.x + safeArea.size.width - closeItem->getContentSize().width / 2;\n        float y = safeArea.origin.y + closeItem->getContentSize().height / 2;\n        closeItem->setPosition(Vec2(x, y));\n        \n        auto menu = Menu::create(closeItem, NULL);\n        menu->setPosition(Vec2::ZERO);\n        this->addChild(menu, 2);\n    }\n\n    scheduleUpdate();\n    return true;\n}\n\nvoid MainScene::update(float delta)\n{\n    if (_artboard && _riveRenderer) {\n        // Clear previous frame\n        _riveDrawNode->clear();\n        \n        // Advance animation\n        // Note: In a real app you would advance the StateMachine or AnimationInstance here.\n        // For the artboard itself, advance updates components.\n        _artboard->advance(delta);\n        \n        // Center and scale the artboard to fit the screen\n        auto visibleSize = _director->getVisibleSize();\n        \n        _riveRenderer->save();\n        _riveRenderer->align(rive::Fit::contain, rive::Alignment::center,\n                             rive::AABB(0, 0, visibleSize.width, visibleSize.height),\n                             _artboard->bounds());\n        \n        _artboard->draw(_riveRenderer.get());\n        _riveRenderer->restore();\n    }\n}\n\nvoid MainScene::menuCloseCallback(ax::Object* sender)\n{\n    _director->end();\n}\n\nvoid MainScene::onTouchesBegan(const std::vector<ax::Touch*>& touches, ax::Event* event) {}\nvoid MainScene::onTouchesMoved(const std::vector<ax::Touch*>& touches, ax::Event* event) {}\nvoid MainScene::onTouchesEnded(const std::vector<ax::Touch*>& touches, ax::Event* event) {}\n",
  "after": "#include \"MainScene.h\"\n#include \"AxmolRive.h\"\n#include \"rive/file.hpp\"\n#include \"rive/artboard.hpp\"\n#include \"rive/animation/linear_animation_instance.hpp\"\n#include \"rive/scene.hpp\"\n#include \"rive/math/mat2d.hpp\"\n\nusing namespace ax;\n\nMainScene::MainScene()\n{\n}\n\nMainScene::~MainScene()\n{\n    if (_touchListener)\n        _eventDispatcher->removeEventListener(_touchListener);\n}\n\nbool MainScene::init()\n{\n    if (!Scene::init())\n    {\n        return false;\n    }\n\n    auto visibleSize = _director->getVisibleSize();\n    auto origin = _director->getVisibleOrigin();\n    auto safeArea = _director->getSafeAreaRect();\n\n    // 1. Background\n    auto background = LayerColor::create(Color32(40, 40, 40, 255));\n    this->addChild(background, 0);\n\n    // 2. DrawNode for Rive\n    _riveDrawNode = DrawNode::create();\n    this->addChild(_riveDrawNode, 1);\n\n    // 3. Initialize Rive\n    _riveFactory = std::make_unique<AxmolFactory>();\n    _riveRenderer = std::make_unique<AxmolRenderer>(_riveDrawNode);\n\n    // 4. Load .riv File\n    auto fileUtils = FileUtils::getInstance();\n    std::string fullPath = fileUtils->fullPathForFilename(\"marty.riv\");\n    \n    if (fullPath.empty()) {\n        AXLOG(\"Error: marty.riv not found!\");\n    } else {\n        auto data = fileUtils->getDataFromFile(fullPath);\n        if (!data.isNull()) {\n            rive::Span<const uint8_t> bytes(data.getBytes(), data.getSize());\n            \n            rive::ImportResult result;\n            _riveFile = rive::File::import(bytes, _riveFactory.get(), &result);\n            \n            if (_riveFile) {\n                _artboard = _riveFile->artboardDefault();\n                if (_artboard) {\n                    _artboard->advance(0.0f);\n                    \n                    // Play the first animation if available\n                    // auto anim = _artboard->animationAt(0);\n                    // if (anim) {\n                    //    _riveScene = _artboard->instance(); // Wait, Scene/StateMachine logic\n                    // }\n                    // Simple animation playback using LinearAnimationInstance directly?\n                    // Or just advance artboard if it has a state machine?\n                    // For now just show the artboard.\n                    \n                    AXLOG(\"Rive file loaded successfully!\");\n                }\n            } else {\n                AXLOG(\"Failed to import Rive file.\");\n            }\n        }\n    }\n\n    // 5. Close Button\n    auto closeItem = MenuItemImage::create(\"CloseNormal.png\", \"CloseSelected.png\",\n                                           AX_CALLBACK_1(MainScene::menuCloseCallback, this));\n    if (closeItem) {\n        float x = safeArea.origin.x + safeArea.size.width - closeItem->getContentSize().width / 2;\n        float y = safeArea.origin.y + closeItem->getContentSize().height / 2;\n        closeItem->setPosition(Vec2(x, y));\n        \n        auto menu = Menu::create(closeItem, NULL);\n        menu->setPosition(Vec2::ZERO);\n        this->addChild(menu, 2);\n    }\n\n    scheduleUpdate();\n    return true;\n}\n\nvoid MainScene::update(float delta)\n{\n    if (_artboard && _riveRenderer) {\n        // Clear previous frame\n        _riveDrawNode->clear();\n        \n        // Advance animation\n        // Note: In a real app you would advance the StateMachine or AnimationInstance here.\n        // For the artboard itself, advance updates components.\n        _artboard->advance(delta);\n        \n        // Center and scale the artboard to fit the screen\n        auto visibleSize = _director->getVisibleSize();\n        \n        _riveRenderer->save();\n        _riveRenderer->align(rive::Fit::contain, rive::Alignment::center,\n                             rive::AABB(0, 0, visibleSize.width, visibleSize.height),\n                             _artboard->bounds());\n        \n        _artboard->draw(_riveRenderer.get());\n        _riveRenderer->restore();\n    }\n}\n\nvoid MainScene::menuCloseCallback(ax::Object* sender)\n{\n    _director->end();\n}\n\nvoid MainScene::onTouchesBegan(const std::vector<ax::Touch*>& touches, ax::Event* event) {}\nvoid MainScene::onTouchesMoved(const std::vector<ax::Touch*>& touches, ax::Event* event) {}\nvoid MainScene::onTouchesEnded(const std::vector<ax::Touch*>& touches, ax::Event* event) {}\n",
  "diff": "Index: file:///Users/arthurmotelevicz/Projects/AITomatoes/axmol_rive/HelloWorld/Source/MainScene.cpp\n===================================================================\n--- file:///Users/arthurmotelevicz/Projects/AITomatoes/axmol_rive/HelloWorld/Source/MainScene.cpp\toriginal\n+++ file:///Users/arthurmotelevicz/Projects/AITomatoes/axmol_rive/HelloWorld/Source/MainScene.cpp\tmodified\n@@ -1,27 +1,22 @@\n-/****************************************************************************\n- Copyright (c) 2019-present Axmol Engine contributors (see AUTHORS.md).\n-\n- https://axmol.dev/\n- ****************************************************************************/\n-\n #include \"MainScene.h\"\n+#include \"AxmolRive.h\"\n+#include \"rive/file.hpp\"\n+#include \"rive/artboard.hpp\"\n+#include \"rive/animation/linear_animation_instance.hpp\"\n+#include \"rive/scene.hpp\"\n+#include \"rive/math/mat2d.hpp\"\n \n using namespace ax;\n \n MainScene::MainScene()\n {\n-    _sceneID = 1;\n }\n \n MainScene::~MainScene()\n {\n     if (_touchListener)\n         _eventDispatcher->removeEventListener(_touchListener);\n-    if (_keyboardListener)\n-        _eventDispatcher->removeEventListener(_keyboardListener);\n-    if (_mouseListener)\n-        _eventDispatcher->removeEventListener(_mouseListener);\n }\n \n bool MainScene::init()\n {\n@@ -33,115 +28,57 @@\n     auto visibleSize = _director->getVisibleSize();\n     auto origin = _director->getVisibleOrigin();\n     auto safeArea = _director->getSafeAreaRect();\n \n-    // 1. Create a solid background color\n-    auto background = LayerColor::create(Color32(30, 30, 30, 255));\n+    // 1. Background\n+    auto background = LayerColor::create(Color32(40, 40, 40, 255));\n     this->addChild(background, 0);\n \n-    // 2. Add a title\n-    auto label = Label::createWithTTF(\"Axmol Drawing Primitives\", \"fonts/Marker Felt.ttf\", 24);\n-    if (label) {\n-        label->setPosition(Vec2(origin.x + visibleSize.width / 2,\n-                                origin.y + visibleSize.height - label->getContentSize().height - 10));\n-        this->addChild(label, 1);\n-    }\n+    // 2. DrawNode for Rive\n+    _riveDrawNode = DrawNode::create();\n+    this->addChild(_riveDrawNode, 1);\n \n-    // 3. Create a DrawNode\n-    auto drawNode = DrawNode::create();\n-    // drawNode->setLineWidth(2.0f); // Set line width for this DrawNode\n-    this->addChild(drawNode, 2);\n+    // 3. Initialize Rive\n+    _riveFactory = std::make_unique<AxmolFactory>();\n+    _riveRenderer = std::make_unique<AxmolRenderer>(_riveDrawNode);\n \n-    // --- Drawing Examples ---\n-    float startX = origin.x + 50;\n-    float startY = origin.y + visibleSize.height - 100;\n-    float gapX = 150;\n-    float gapY = 150;\n+    // 4. Load .riv File\n+    auto fileUtils = FileUtils::getInstance();\n+    std::string fullPath = fileUtils->fullPathForFilename(\"marty.riv\");\n     \n-    // Example 1: Points/Dots\n-    drawNode->drawDot(Vec2(startX, startY), 10, Color::RED);\n-    drawNode->drawDot(Vec2(startX + 30, startY), 10, Color::GREEN);\n-    drawNode->drawDot(Vec2(startX + 60, startY), 10, Color::BLUE);\n+    if (fullPath.empty()) {\n+        AXLOG(\"Error: marty.riv not found!\");\n+    } else {\n+        auto data = fileUtils->getDataFromFile(fullPath);\n+        if (!data.isNull()) {\n+            rive::Span<const uint8_t> bytes(data.getBytes(), data.getSize());\n             \n-    auto labelDots = Label::createWithSystemFont(\"Dots\", \"Arial\", 12);\n-    labelDots->setPosition(Vec2(startX + 30, startY - 30));\n-    this->addChild(labelDots, 2);\n+            rive::ImportResult result;\n+            _riveFile = rive::File::import(bytes, _riveFactory.get(), &result);\n             \n-    // Example 2: Segments (Lines)\n-    startX += gapX;\n-    drawNode->drawLine(Vec2(startX, startY - 10), Vec2(startX + 80, startY + 10), Color::YELLOW);\n-    // drawSegment allows setting thickness\n-    drawNode->drawSegment(Vec2(startX, startY - 30), Vec2(startX + 80, startY - 10), 5.0f, Color::MAGENTA);\n+            if (_riveFile) {\n+                _artboard = _riveFile->artboardDefault();\n+                if (_artboard) {\n+                    _artboard->advance(0.0f);\n                     \n-    auto labelLines = Label::createWithSystemFont(\"Lines\", \"Arial\", 12);\n-    labelLines->setPosition(Vec2(startX + 40, startY - 50));\n-    this->addChild(labelLines, 2);\n+                    // Play the first animation if available\n+                    // auto anim = _artboard->animationAt(0);\n+                    // if (anim) {\n+                    //    _riveScene = _artboard->instance(); // Wait, Scene/StateMachine logic\n+                    // }\n+                    // Simple animation playback using LinearAnimationInstance directly?\n+                    // Or just advance artboard if it has a state machine?\n+                    // For now just show the artboard.\n                     \n-    // Example 3: Circles\n-    startX += gapX;\n-    // center, radius, angle, segments, drawLineToCenter, scaleX, scaleY\n-    drawNode->drawCircle(Vec2(startX + 40, startY), 30, 0, 50, false, 1.0f, 1.0f, Color::WHITE);\n-    drawNode->drawSolidCircle(Vec2(startX + 40, startY - 40), 20, 0, 50, 1.0f, 1.0f, Color(0.0f, 1.0f, 1.0f, 0.5f)); // Semi-transparent cyan\n+                    AXLOG(\"Rive file loaded successfully!\");\n+                }\n+            } else {\n+                AXLOG(\"Failed to import Rive file.\");\n+            }\n+        }\n+    }\n \n-    auto labelCircles = Label::createWithSystemFont(\"Circles\", \"Arial\", 12);\n-    labelCircles->setPosition(Vec2(startX + 40, startY - 80));\n-    this->addChild(labelCircles, 2);\n-\n-    // Example 4: Rectangles\n-    startX = origin.x + 50;\n-    startY -= gapY;\n-    drawNode->drawRect(Vec2(startX, startY), Vec2(startX + 80, startY + 60), Color::ORANGE);\n-    drawNode->drawSolidRect(Vec2(startX + 10, startY + 10), Vec2(startX + 70, startY + 50), Color(1.0f, 0.5f, 0.0f, 0.5f));\n-\n-    auto labelRects = Label::createWithSystemFont(\"Rects\", \"Arial\", 12);\n-    labelRects->setPosition(Vec2(startX + 40, startY - 20));\n-    this->addChild(labelRects, 2);\n-\n-    // Example 5: Polygons\n-    startX += gapX;\n-    Vec2 points[] = {\n-        Vec2(startX, startY),\n-        Vec2(startX + 40, startY + 60),\n-        Vec2(startX + 80, startY + 20),\n-        Vec2(startX + 40, startY - 20)\n-    };\n-    drawNode->drawPolygon(points, 4, Color(0.5f, 0.0f, 0.5f, 0.5f), 2, Color::MAGENTA);\n-\n-    auto labelPoly = Label::createWithSystemFont(\"Polygon\", \"Arial\", 12);\n-    labelPoly->setPosition(Vec2(startX + 40, startY - 40));\n-    this->addChild(labelPoly, 2);\n-\n-    // Example 6: Bezier Curves\n-    startX += gapX;\n-    // Quadratic\n-    drawNode->drawQuadBezier(Vec2(startX, startY), Vec2(startX + 40, startY + 80), Vec2(startX + 80, startY), 50, Color::GREEN);\n-    // Cubic\n-    drawNode->drawCubicBezier(Vec2(startX, startY - 20), Vec2(startX + 20, startY - 60), Vec2(startX + 60, startY + 20), Vec2(startX + 80, startY - 20), 50, Color::RED);\n-\n-    auto labelBezier = Label::createWithSystemFont(\"Bezier\", \"Arial\", 12);\n-    labelBezier->setPosition(Vec2(startX + 40, startY - 40));\n-    this->addChild(labelBezier, 2);\n-\n-    // Example 7: Catmull-Rom Spline (Cardinal Spline)\n-    startX = origin.x + 50;\n-    startY -= gapY;\n-    \n-    auto splinePoints = PointArray::create(5);\n-    splinePoints->addControlPoint(Vec2(startX, startY));\n-    splinePoints->addControlPoint(Vec2(startX + 30, startY + 50));\n-    splinePoints->addControlPoint(Vec2(startX + 60, startY - 20));\n-    splinePoints->addControlPoint(Vec2(startX + 90, startY + 40));\n-    splinePoints->addControlPoint(Vec2(startX + 120, startY));\n-    drawNode->drawCardinalSpline(splinePoints, 0.5f, 50, Color(0.0f, 1.0f, 1.0f, 1.0f));\n-\n-    auto labelSpline = Label::createWithSystemFont(\"Cardinal Spline\", \"Arial\", 12);\n-    labelSpline->setPosition(Vec2(startX + 60, startY - 20));\n-    this->addChild(labelSpline, 2);\n-\n-    // Update loop for animations if needed\n-    scheduleUpdate();\n-\n-    // Close button\n+    // 5. Close Button\n     auto closeItem = MenuItemImage::create(\"CloseNormal.png\", \"CloseSelected.png\",\n                                            AX_CALLBACK_1(MainScene::menuCloseCallback, this));\n     if (closeItem) {\n         float x = safeArea.origin.x + safeArea.size.width - closeItem->getContentSize().width / 2;\n@@ -149,30 +86,43 @@\n         closeItem->setPosition(Vec2(x, y));\n         \n         auto menu = Menu::create(closeItem, NULL);\n         menu->setPosition(Vec2::ZERO);\n-        this->addChild(menu, 1);\n+        this->addChild(menu, 2);\n     }\n \n+    scheduleUpdate();\n     return true;\n }\n \n void MainScene::update(float delta)\n {\n-    // Optional: Add animations here\n+    if (_artboard && _riveRenderer) {\n+        // Clear previous frame\n+        _riveDrawNode->clear();\n+        \n+        // Advance animation\n+        // Note: In a real app you would advance the StateMachine or AnimationInstance here.\n+        // For the artboard itself, advance updates components.\n+        _artboard->advance(delta);\n+        \n+        // Center and scale the artboard to fit the screen\n+        auto visibleSize = _director->getVisibleSize();\n+        \n+        _riveRenderer->save();\n+        _riveRenderer->align(rive::Fit::contain, rive::Alignment::center,\n+                             rive::AABB(0, 0, visibleSize.width, visibleSize.height),\n+                             _artboard->bounds());\n+        \n+        _artboard->draw(_riveRenderer.get());\n+        _riveRenderer->restore();\n     }\n+}\n \n void MainScene::menuCloseCallback(ax::Object* sender)\n {\n     _director->end();\n }\n \n-// Input handling stubs\n void MainScene::onTouchesBegan(const std::vector<ax::Touch*>& touches, ax::Event* event) {}\n void MainScene::onTouchesMoved(const std::vector<ax::Touch*>& touches, ax::Event* event) {}\n void MainScene::onTouchesEnded(const std::vector<ax::Touch*>& touches, ax::Event* event) {}\n-bool MainScene::onMouseDown(Event* event) { return true; }\n-bool MainScene::onMouseUp(Event* event) { return true; }\n-bool MainScene::onMouseMove(Event* event) { return true; }\n-bool MainScene::onMouseScroll(Event* event) { return true; }\n-void MainScene::onKeyPressed(EventKeyboard::KeyCode code, Event* event) {}\n-void MainScene::onKeyReleased(EventKeyboard::KeyCode code, Event* event) {}\n",
  "isNewFile": false,
  "reverted": false,
  "timestamp": 1763773618397
}