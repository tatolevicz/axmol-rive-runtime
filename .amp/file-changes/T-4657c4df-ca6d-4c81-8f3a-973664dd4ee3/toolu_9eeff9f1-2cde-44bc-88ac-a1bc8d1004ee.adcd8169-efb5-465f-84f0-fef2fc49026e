{
  "id": "adcd8169-efb5-465f-84f0-fef2fc49026e",
  "uri": "file:///Users/arthurmotelevicz/Projects/AITomatoes/axmol_rive/HelloWorld/Source/AxmolRive.h",
  "before": "#ifndef _AXMOL_RIVE_H_\n#define _AXMOL_RIVE_H_\n\n#include \"axmol.h\"\n\n// Rive includes\n#include \"rive/renderer.hpp\"\n#include \"rive/factory.hpp\"\n#include \"rive/tess/tess_renderer.hpp\"\n#include \"rive/tess/tess_render_path.hpp\"\n\n#include <vector>\n\nnamespace rive {\n    class RawPath;\n}\n\nclass AxmolRenderPath : public rive::TessRenderPath {\npublic:\n    AxmolRenderPath(rive::RawPath& rawPath, rive::FillRule fillRule);\n    ~AxmolRenderPath() override = default;\n\n    // Called by TessRenderPath::triangulate\n    void addTriangles(rive::Span<const rive::Vec2D> vertices, rive::Span<const uint16_t> indices) override;\n    void setTriangulatedBounds(const rive::AABB& value) override;\n\n    // Store the triangles\n    std::vector<ax::V2F_C4B_T2F> _triVertices;\n    std::vector<unsigned short> _triIndices;\n    \n    // Temporary storage for vertices before applying color\n    std::vector<rive::Vec2D> _rawVertices;\n    std::vector<uint16_t> _rawIndices;\n};\n\nclass AxmolRenderPaint : public rive::RenderPaint {\npublic:\n    AxmolRenderPaint();\n    \n    void style(rive::RenderPaintStyle style) override;\n    void color(rive::ColorInt value) override;\n    void thickness(float value) override;\n    void join(rive::StrokeJoin value) override;\n    void cap(rive::StrokeCap value) override;\n    void blendMode(rive::BlendMode value) override;\n    void shader(rive::rcp<rive::RenderShader>) override;\n    void invalidateStroke() override;\n\n    rive::RenderPaintStyle _style = rive::RenderPaintStyle::fill;\n    rive::ColorInt _color = 0xFFFFFFFF;\n    float _thickness = 1.0f;\n    rive::StrokeJoin _join = rive::StrokeJoin::miter;\n    rive::StrokeCap _cap = rive::StrokeCap::butt;\n    rive::BlendMode _blendMode = rive::BlendMode::srcOver;\n};\n\nclass AxmolRenderer : public rive::TessRenderer {\npublic:\n    AxmolRenderer(ax::DrawNode* drawNode);\n    \n    void drawPath(rive::RenderPath* path, rive::RenderPaint* paint) override;\n    void clipPath(rive::RenderPath* path) override;\n    \n    // Stub implementations for pure virtuals in TessRenderer/Renderer\n    void orthographicProjection(float left, float right, float bottom, float top, float near, float far) override {}\n    \n    // Images - Stub for now\n    void drawImage(const rive::RenderImage*, rive::ImageSampler, rive::BlendMode, float opacity) override {}\n    void drawImageMesh(const rive::RenderImage*, rive::ImageSampler, rive::rcp<rive::RenderBuffer>, rive::rcp<rive::RenderBuffer>, rive::rcp<rive::RenderBuffer>, uint32_t, uint32_t, rive::BlendMode, float) override {}\n\nprivate:\n    ax::DrawNode* _drawNode;\n};\n\nclass AxmolFactory : public rive::Factory {\npublic:\n    rive::rcp<rive::RenderBuffer> makeRenderBuffer(rive::RenderBufferType, rive::RenderBufferFlags, size_t sizeInBytes) override;\n    \n    rive::rcp<rive::RenderShader> makeLinearGradient(\n        float sx, float sy, float ex, float ey,\n        const rive::ColorInt colors[], const float stops[], size_t count) override;\n    \n    rive::rcp<rive::RenderShader> makeRadialGradient(\n        float cx, float cy, float radius,\n        const rive::ColorInt colors[], const float stops[], size_t count) override;\n        \n    rive::rcp<rive::RenderPath> makeRenderPath(rive::RawPath& rawPath, rive::FillRule fillRule) override;\n    rive::rcp<rive::RenderPath> makeEmptyRenderPath() override;\n    rive::rcp<rive::RenderPaint> makeRenderPaint() override;\n    rive::rcp<rive::RenderImage> decodeImage(rive::Span<const uint8_t>) override;\n};\n\n#endif // _AXMOL_RIVE_H_\n",
  "after": "#ifndef _AXMOL_RIVE_H_\n#define _AXMOL_RIVE_H_\n\n#include \"axmol/axmol.h\"\n\n// Rive includes\n#include \"rive/renderer.hpp\"\n#include \"rive/factory.hpp\"\n#include \"rive/tess/tess_renderer.hpp\"\n#include \"rive/tess/tess_render_path.hpp\"\n\n#include <vector>\n\nnamespace rive {\n    class RawPath;\n}\n\nclass AxmolRenderPath : public rive::TessRenderPath {\npublic:\n    AxmolRenderPath(rive::RawPath& rawPath, rive::FillRule fillRule);\n    ~AxmolRenderPath() override = default;\n\n    // Called by TessRenderPath::triangulate\n    void addTriangles(rive::Span<const rive::Vec2D> vertices, rive::Span<const uint16_t> indices) override;\n    void setTriangulatedBounds(const rive::AABB& value) override;\n\n    // Store the triangles\n    std::vector<ax::V2F_C4B_T2F> _triVertices;\n    std::vector<unsigned short> _triIndices;\n    \n    // Temporary storage for vertices before applying color\n    std::vector<rive::Vec2D> _rawVertices;\n    std::vector<uint16_t> _rawIndices;\n};\n\nclass AxmolRenderPaint : public rive::RenderPaint {\npublic:\n    AxmolRenderPaint();\n    \n    void style(rive::RenderPaintStyle style) override;\n    void color(rive::ColorInt value) override;\n    void thickness(float value) override;\n    void join(rive::StrokeJoin value) override;\n    void cap(rive::StrokeCap value) override;\n    void blendMode(rive::BlendMode value) override;\n    void shader(rive::rcp<rive::RenderShader>) override;\n    void invalidateStroke() override;\n\n    rive::RenderPaintStyle _style = rive::RenderPaintStyle::fill;\n    rive::ColorInt _color = 0xFFFFFFFF;\n    float _thickness = 1.0f;\n    rive::StrokeJoin _join = rive::StrokeJoin::miter;\n    rive::StrokeCap _cap = rive::StrokeCap::butt;\n    rive::BlendMode _blendMode = rive::BlendMode::srcOver;\n};\n\nclass AxmolRenderer : public rive::TessRenderer {\npublic:\n    AxmolRenderer(ax::DrawNode* drawNode);\n    \n    void drawPath(rive::RenderPath* path, rive::RenderPaint* paint) override;\n    void clipPath(rive::RenderPath* path) override;\n    \n    // Stub implementations for pure virtuals in TessRenderer/Renderer\n    void orthographicProjection(float left, float right, float bottom, float top, float near, float far) override {}\n    \n    // Images - Stub for now\n    void drawImage(const rive::RenderImage*, rive::ImageSampler, rive::BlendMode, float opacity) override {}\n    void drawImageMesh(const rive::RenderImage*, rive::ImageSampler, rive::rcp<rive::RenderBuffer>, rive::rcp<rive::RenderBuffer>, rive::rcp<rive::RenderBuffer>, uint32_t, uint32_t, rive::BlendMode, float) override {}\n\nprivate:\n    ax::DrawNode* _drawNode;\n};\n\nclass AxmolFactory : public rive::Factory {\npublic:\n    rive::rcp<rive::RenderBuffer> makeRenderBuffer(rive::RenderBufferType, rive::RenderBufferFlags, size_t sizeInBytes) override;\n    \n    rive::rcp<rive::RenderShader> makeLinearGradient(\n        float sx, float sy, float ex, float ey,\n        const rive::ColorInt colors[], const float stops[], size_t count) override;\n    \n    rive::rcp<rive::RenderShader> makeRadialGradient(\n        float cx, float cy, float radius,\n        const rive::ColorInt colors[], const float stops[], size_t count) override;\n        \n    rive::rcp<rive::RenderPath> makeRenderPath(rive::RawPath& rawPath, rive::FillRule fillRule) override;\n    rive::rcp<rive::RenderPath> makeEmptyRenderPath() override;\n    rive::rcp<rive::RenderPaint> makeRenderPaint() override;\n    rive::rcp<rive::RenderImage> decodeImage(rive::Span<const uint8_t>) override;\n};\n\n#endif // _AXMOL_RIVE_H_\n",
  "diff": "Index: file:///Users/arthurmotelevicz/Projects/AITomatoes/axmol_rive/HelloWorld/Source/AxmolRive.h\n===================================================================\n--- file:///Users/arthurmotelevicz/Projects/AITomatoes/axmol_rive/HelloWorld/Source/AxmolRive.h\toriginal\n+++ file:///Users/arthurmotelevicz/Projects/AITomatoes/axmol_rive/HelloWorld/Source/AxmolRive.h\tmodified\n@@ -0,0 +1,93 @@\n+#ifndef _AXMOL_RIVE_H_\n+#define _AXMOL_RIVE_H_\n+\n+#include \"axmol/axmol.h\"\n+\n+// Rive includes\n+#include \"rive/renderer.hpp\"\n+#include \"rive/factory.hpp\"\n+#include \"rive/tess/tess_renderer.hpp\"\n+#include \"rive/tess/tess_render_path.hpp\"\n+\n+#include <vector>\n+\n+namespace rive {\n+    class RawPath;\n+}\n+\n+class AxmolRenderPath : public rive::TessRenderPath {\n+public:\n+    AxmolRenderPath(rive::RawPath& rawPath, rive::FillRule fillRule);\n+    ~AxmolRenderPath() override = default;\n+\n+    // Called by TessRenderPath::triangulate\n+    void addTriangles(rive::Span<const rive::Vec2D> vertices, rive::Span<const uint16_t> indices) override;\n+    void setTriangulatedBounds(const rive::AABB& value) override;\n+\n+    // Store the triangles\n+    std::vector<ax::V2F_C4B_T2F> _triVertices;\n+    std::vector<unsigned short> _triIndices;\n+    \n+    // Temporary storage for vertices before applying color\n+    std::vector<rive::Vec2D> _rawVertices;\n+    std::vector<uint16_t> _rawIndices;\n+};\n+\n+class AxmolRenderPaint : public rive::RenderPaint {\n+public:\n+    AxmolRenderPaint();\n+    \n+    void style(rive::RenderPaintStyle style) override;\n+    void color(rive::ColorInt value) override;\n+    void thickness(float value) override;\n+    void join(rive::StrokeJoin value) override;\n+    void cap(rive::StrokeCap value) override;\n+    void blendMode(rive::BlendMode value) override;\n+    void shader(rive::rcp<rive::RenderShader>) override;\n+    void invalidateStroke() override;\n+\n+    rive::RenderPaintStyle _style = rive::RenderPaintStyle::fill;\n+    rive::ColorInt _color = 0xFFFFFFFF;\n+    float _thickness = 1.0f;\n+    rive::StrokeJoin _join = rive::StrokeJoin::miter;\n+    rive::StrokeCap _cap = rive::StrokeCap::butt;\n+    rive::BlendMode _blendMode = rive::BlendMode::srcOver;\n+};\n+\n+class AxmolRenderer : public rive::TessRenderer {\n+public:\n+    AxmolRenderer(ax::DrawNode* drawNode);\n+    \n+    void drawPath(rive::RenderPath* path, rive::RenderPaint* paint) override;\n+    void clipPath(rive::RenderPath* path) override;\n+    \n+    // Stub implementations for pure virtuals in TessRenderer/Renderer\n+    void orthographicProjection(float left, float right, float bottom, float top, float near, float far) override {}\n+    \n+    // Images - Stub for now\n+    void drawImage(const rive::RenderImage*, rive::ImageSampler, rive::BlendMode, float opacity) override {}\n+    void drawImageMesh(const rive::RenderImage*, rive::ImageSampler, rive::rcp<rive::RenderBuffer>, rive::rcp<rive::RenderBuffer>, rive::rcp<rive::RenderBuffer>, uint32_t, uint32_t, rive::BlendMode, float) override {}\n+\n+private:\n+    ax::DrawNode* _drawNode;\n+};\n+\n+class AxmolFactory : public rive::Factory {\n+public:\n+    rive::rcp<rive::RenderBuffer> makeRenderBuffer(rive::RenderBufferType, rive::RenderBufferFlags, size_t sizeInBytes) override;\n+    \n+    rive::rcp<rive::RenderShader> makeLinearGradient(\n+        float sx, float sy, float ex, float ey,\n+        const rive::ColorInt colors[], const float stops[], size_t count) override;\n+    \n+    rive::rcp<rive::RenderShader> makeRadialGradient(\n+        float cx, float cy, float radius,\n+        const rive::ColorInt colors[], const float stops[], size_t count) override;\n+        \n+    rive::rcp<rive::RenderPath> makeRenderPath(rive::RawPath& rawPath, rive::FillRule fillRule) override;\n+    rive::rcp<rive::RenderPath> makeEmptyRenderPath() override;\n+    rive::rcp<rive::RenderPaint> makeRenderPaint() override;\n+    rive::rcp<rive::RenderImage> decodeImage(rive::Span<const uint8_t>) override;\n+};\n+\n+#endif // _AXMOL_RIVE_H_\n",
  "isNewFile": false,
  "reverted": false,
  "timestamp": 1763773514966
}